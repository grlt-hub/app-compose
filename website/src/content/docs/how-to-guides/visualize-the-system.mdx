---
title: Visualize the System
sidebar:
  order: 9
  badge:
    text: New
    variant: tip
---

Visualizing the system composed of containers is crucial for understanding dependencies and interactions within your application. Here’s how to effectively use the visualization tool.

We’ll explore:

- **Using the** `compose.graph`: How to visualize the system composed of containers.

## Example

```ts {10}
import { createContainer, compose } from '@grlt-hub/app-compose';

const start = () => ({ api: null });

const a = createContainer({ id: 'a', start });
const b = createContainer({ id: 'b', dependsOn: [a], start });
const c = createContainer({ id: 'c', optionalDependsOn: [b], start });
const d = createContainer({ id: 'd', dependsOn: [c], optionalDependsOn: [b], start });

const graph = graphFn([a, b, c, d]);

console.log(graph);
```

### Expected Result

The output of `compose.graph` provides a detailed breakdown of each container:

- **Direct Dependencies**:
  - **Strict**: Lists containers that are `strict` dependencies of the current container.
  - **Optional**: Lists containers that are `optional` dependencies of the current container.
- **Transitive Dependencies**:
  - **Strict**: Lists containers that are `strict` dependencies, inherited through a chain of dependencies.
  - **Optional**: Lists containers that are `optional` dependencies, inherited through a chain of dependencies.
- **Transitive Dependency Paths**:
  - Each transitive dependency includes a path that describes how the dependency is reached, which is helpful for tracing and debugging.

```json
{
  "a": {
    "strict": [],
    "optional": [],
    "transitive": { "strict": [], "optional": [] }
  },
  "b": {
    "strict": ["a"],
    "optional": [],
    "transitive": { "strict": [], "optional": [] }
  },
  "c": {
    "strict": [],
    "optional": ["b"],
    "transitive": {
      "strict": [],
      "optional": [{ "id": "a", "path": "c -> b -> a" }]
    }
  },
  "d": {
    "strict": ["c"],
    "optional": ["b"],
    "transitive": {
      "strict": [],
      "optional": [{ "id": "a", "path": "d -> b -> a" }]
    }
  }
}
```

## When to Use `compose.graph`

- **Debugging**: Use the graph output to identify and resolve potential issues, such as missing or transitive (hidden) dependencies.
- **Optimizing Architecture**: Analyze the dependency structure to refactor and optimize your application's architecture.
- **Documenting Dependencies**: Generate a visual representation to document the architecture for your team.

## Notes

- Ensure that all containers are defined with proper `dependsOn` and `optionalDependsOn` attributes.
- The `compose.graph` function does not modify your containers; it only provides a visualization of the dependencies.

## Rules for Classifying Dependencies

1. **Direct Dependencies**:

   - A dependency is considered **direct** if it is explicitly declared in the `dependsOn` or `optionalDependsOn` lists of a container.
   - Direct dependencies are categorized as:
     - **Strict**: If they are listed in `dependsOn`.
     - **Optional**: If they are listed in `optionalDependsOn`.

2. **Transitive Dependencies**:

   - A dependency is considered **transitive** if it is inherited through a chain of dependencies from another container, rather than being directly listed.
   - **Classification of Transitive Dependencies**:
     - If a dependency path begins from a **strict** direct dependency, all subsequent dependencies in the chain are also **strict**.
     - If a dependency path begins from an **optional** direct dependency, all subsequent dependencies in the chain are **optional**, regardless of their original type.

3. **Propagation of Dependency Type**:
   - The strictness of a transitive dependency is determined by the type of the initial direct dependency in the chain:
     - If the initial direct dependency is **strict**, the entire chain is considered **strict**.
     - If the initial direct dependency is **optional**, the entire chain is considered **optional**.

These rules ensures that the classification of dependencies is consistent and reflects both direct and inherited relationships in a system.

## Conclusion

Using `compose.graph` allows you to have a comprehensive understanding of the container-based architecture of your application. This tool is essential for debugging, optimizing, and documenting the dependencies and interactions between various parts of your system.
